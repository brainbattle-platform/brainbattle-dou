// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// BrainBattle Duo MVP Schema
// Aligned with Figma flow: Unit (topic) → Planet (lesson) → 4 modes (listening/speaking/reading/writing)
// NOTE: Content (lessons, exercises) stored in-memory, only progress/runtime state in DB

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Quiz attempt (stable attemptId stored in DB)
model QuizAttempt {
  id              String           @id @default(cuid())
  userId          Int
  lessonId        String           // Lesson being practiced
  mode            String           // Modality: "listening" | "speaking" | "reading" | "writing"
  unitId          String           // Unit (topic) this attempt belongs to
  questionIds     String[]         // Ordered list of question IDs for this mode
  startedAt       DateTime         @default(now())
  finishedAt      DateTime?
  correctCount    Int              @default(0)
  totalQuestions  Int              @default(0)
  xpEarned        Int              @default(0)
  questionAttempts QuestionAttempt[]

  @@index([userId, lessonId])
  @@index([userId, unitId])
  @@index([userId, startedAt])
  @@map("quiz_attempts")
}

// Individual question attempt within a quiz (stores each submitted answer)
model QuestionAttempt {
  id              String       @id @default(cuid())
  attemptId       String       // Quiz attempt ID (stable)
  userId          Int
  questionId      String       // Exercise/question ID (content stored in-memory)
  selectedOptionId String?     // For MCQ: selected option index or text
  answerText      String?      // For text-based answers
  answerJson      Json?        // For complex answers (match, etc.)
  isCorrect       Boolean
  answeredAt      DateTime    @default(now())
  timeMs          Int?         // Time taken in milliseconds
  attempt         QuizAttempt  @relation(fields: [attemptId], references: [id], onDelete: Cascade)

  @@unique([attemptId, questionId]) // Prevent duplicate submissions per attempt
  @@index([attemptId])
  @@index([userId, questionId])
  @@index([userId, answeredAt])
  @@map("question_attempts")
}

// Legacy: Runtime learning session tracking (kept for backward compatibility)
model LessonSession {
  id           String   @id @default(cuid())
  userId       Int
  unitId       String   // Unit (topic) this session belongs to
  lessonId     String   // Planet (lesson) being practiced
  mode         String   // Modality: "listening" | "speaking" | "reading" | "writing"
  startedAt    DateTime @default(now())
  finishedAt   DateTime?
  correctCount Int      @default(0)
  totalCount   Int      @default(0) // totalQuestions in this session
  xpEarned     Int      @default(0)
  attempts     Attempt[]

  @@index([userId, lessonId])
  @@index([userId, unitId])
}

// Legacy: Individual question/exercise attempt within a session
model Attempt {
  id         String        @id @default(cuid())
  sessionId  String
  questionId String        // Exercise/question ID (content stored in-memory)
  mode       String        // Modality for which this attempt was made
  isCorrect  Boolean
  answer     Json          // User's answer (can be string, object for match, etc.)
  timeMs     Int?          // Time taken in milliseconds
  createdAt  DateTime      @default(now())
  session    LessonSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId, questionId]) // Prevent duplicate submissions
}

// User's overall learning progress
model UserProgress {
  userId        Int      @id
  xpTotal       Int      @default(0)
  streak        Int      @default(0)
  lastActiveDate DateTime @default(now())
  
  // Progress tracking relations
  unitProgress  UnitProgress[]
  planetModeProgress PlanetModeProgress[]
  userHearts   UserHearts?

  @@map("user_progress")
}

// User hearts (separate model for better persistence)
model UserHearts {
  userId        Int      @id
  current       Int      @default(5)      // Current hearts available
  max           Int      @default(5)      // Maximum hearts (typically 5)
  lastRefillAt  DateTime @default(now())   // When hearts last regenerated
  user          UserProgress @relation(fields: [userId], references: [userId], onDelete: Cascade)

  @@map("user_hearts")
}

// Mastery progress per Unit (topic)
model UnitProgress {
  userId  Int
  unitId  String  // Unit (topic) ID (e.g., "unit-1")
  mastery Int     @default(0) // Mastery level for this unit
  user    UserProgress @relation(fields: [userId], references: [userId], onDelete: Cascade)

  @@id([userId, unitId])
  @@map("unit_progress")
}

// Progress tracking per Planet (lesson) × Mode combination
// Enables: "How many modes completed for this planet?" and "What's my best score in listening for this lesson?"
model PlanetModeProgress {
  userId      Int
  lessonId    String  // Planet (lesson) ID
  mode        String  // Modality: "listening" | "speaking" | "reading" | "writing"
  state       String  @default("available") // "available" | "locked" | "completed"
  bestScore   Float   @default(0.0)         // Best accuracy achieved (0.0 - 1.0)
  completedAt DateTime?                     // When this mode was first completed
  lastAttemptAt DateTime?                   // Last time user practiced this mode
  user        UserProgress @relation(fields: [userId], references: [userId], onDelete: Cascade)

  @@id([userId, lessonId, mode])
  @@index([userId, lessonId]) // For queries like "get all modes for a planet"
  @@index([userId, mode])     // For Practice Hub: "weak skills by mode"
  @@map("planet_mode_progress")
}

// User lesson progress (alias for better clarity)
// This is the same as PlanetModeProgress but provides a clearer name
// We keep PlanetModeProgress for backward compatibility

// ============================================
// Content Management Models (Admin CRUD)
// ============================================

// Unit (topic) - top-level grouping
model Unit {
  id          String   @id @default(cuid())
  unitId      String   @unique // Legacy ID for backward compatibility (e.g., "unit-1")
  title       String
  order       Int      @default(0)
  published   Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  lessons     Lesson[]

  @@index([order])
  @@index([published])
  @@map("units")
}

// Lesson (planet) - belongs to a unit
model Lesson {
  id              String   @id @default(cuid())
  lessonId        String   @unique // Legacy ID for backward compatibility (e.g., "lesson-1-1")
  unitId          String   // References Unit.unitId (not Unit.id for backward compatibility)
  title           String
  subtitle        String?
  order           Int      @default(0)
  estimatedMinutes Int     @default(3)
  published       Boolean  @default(false)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  unit            Unit     @relation(fields: [unitId], references: [unitId], onDelete: Cascade)
  questions       Question[]

  @@index([unitId, order])
  @@index([published])
  @@map("lessons")
}

// Question - belongs to a lesson, has mode and type
model Question {
  id              String   @id @default(cuid())
  questionId      String   @unique // Legacy ID for backward compatibility
  lessonId        String   // References Lesson.lessonId (not Lesson.id for backward compatibility)
  mode            String   // "listening" | "speaking" | "reading" | "writing"
  type            String   @default("MCQ") // "MCQ" | "LISTEN_AND_SELECT" | "TYPE_ANSWER"
  prompt          String
  correctAnswer   String
  explanation     String?
  hint            String?
  audioAssetId    String?  // For LISTEN_AND_SELECT questions - references AudioAsset
  placeholder     String?  // For TYPE_ANSWER questions
  caseSensitive   Boolean  @default(false) // For TYPE_ANSWER questions
  order           Int      @default(0)
  published       Boolean  @default(false)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  lesson          Lesson   @relation(fields: [lessonId], references: [lessonId], onDelete: Cascade)
  options         QuestionOption[]
  audioAsset      AudioAsset? @relation(fields: [audioAssetId], references: [id], onDelete: SetNull)

  @@index([lessonId, mode, order])
  @@index([published])
  @@index([audioAssetId])
  @@map("questions")
}

// Question Option - for MCQ questions (choices)
model QuestionOption {
  id          String   @id @default(cuid())
  questionId String
  text        String
  isCorrect   Boolean  @default(false)
  order       Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  question    Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@index([questionId, order])
  @@map("question_options")
}

// Audio Asset - for LISTEN_AND_SELECT questions
model AudioAsset {
  id           String     @id @default(cuid())
  key          String     @unique // MinIO object key
  bucket       String     @default("bb-learning")
  originalName String
  contentType  String
  size         Int        // Size in bytes
  durationSec  Float?     // Optional duration in seconds
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  questions    Question[] // Questions that use this audio

  @@index([originalName])
  @@map("audio_assets")
}
